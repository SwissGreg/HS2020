\documentclass[8pt]{extreport}
\usepackage{parskip}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{enumitem}
\usepackage{geometry}
\usepackage{float}
\geometry{a4paper, margin=1in}
\title{Theoretische Informatik\\Summary}
\begin{document}
	\maketitle
	\newpage

\chapter{Alphabete, Wörter, Sprachen und die Darstellung von Problemen}

\section{2.2 Alphabete, Wörter und Sprachen}

\underline{\textbf{D2.1:}} Eine endliche nichtleere Menge $\sum$ heisst \textbf{Alphabet}. Die Elemente eines Alphabets werden \textbf{Buchstaben (Zeichen, Symbole)} genannt.

Häufig verwendete Alphabete:
\begin{itemize}
\item $\sum_{bool} = \{0,1\}$
\item $\sum_{lat} = \{a,b,c,...,z\}$
\item $\sum_m = \{0,1,2,...,m-1\}$
\item $\sum_{logic} = \{0,1,x,(,),AND,OR,NOT\}$

\end{itemize}

\underline{\textbf{D2.2:}} Ein \textbf{Wort} über $\sum$ ist eine endliche (eventuell leere) Folge von Buchstaben aus $\sum$. Das leere Wort $\lambda$ (manchmal $\epsilon$) ist die leere Buchstabenfolge. Die \textbf{Länge} $|w|$ eines Wortes w ist die Anzahl der Vorkommen von Buchstaben in w.

\begin{itemize}
\item $\sum^{*}$: Menge aller Wörter über $\sum$
\item $\sum^{+} = \sum^{*}-\{\lambda\}$
\end{itemize}

Das leere Wort $\lambda$ ist ein Wort über jedem Alphabet.

\underline{Verabredung:} Wir werden Wörter ohne Komma schreiben

\underline{\textbf{D2.3:}} Die \textbf{Verkettung (Konkatenation)} für ein Alphabet $\sum$ ist eine Abbildung 
\begin{center}
$Kon(x,y) = x \cdot y = xy$
\end{center}
für alle $x,y \in \sum^{*}$
Die Verkettung ist eine \underline{assoziative} Operation und ($\sum^*,Kon$) ist eine Halbgruppe(Monoid) mit neutralen element $\lambda$\\
Für alle $x,y \in \sum^{*}$ gilt:
\begin{center}
$|xy| = |x \cdot y | = |x| + |y|$
\end{center}
\underline{\textbf{D2.4:}} Für ein Wort $a=a_1a_2a_3...a_n$ mit $a_i \in \sum$ für $i \in \{1,2,...,n\}$, bezeichnet $a^{R} = a_na_{n-1}...a_1$ die \textbf{Umkehrung} von a.\\
\underline{\textbf{D2.5:}} Sei $\sum$ ein Alphabet. Für alle $x \in \sum^{*}$ und alle $i \in \mathbb{N}$ definieren wir die i-te \textbf{Iteration} $x^i$ von x als
\begin{center}
$x^0 = \lambda, x^1 = x und x^i = xx^{i-1}$
\end{center}
\underline{Beispiel:} aabbaaaaaa = $a^2b^2a^6$

\underline{\textbf{D2.6:}} Seien v,w $\in \sum^*$ für ein Alphabet $\sum$
\begin{itemize}
\item v heisst ein \textbf{Teilwort} von w $\iff \exists x,y \in \sum^*: w = xvy$
\item v heisst ein \textbf{Präfix} von w $\iff \exists y \in \sum^*: w = vy$
\item v heisst ein \textbf{Suffix} von w $\iff \exists x \in \sum^*: w = xv$
\end{itemize}


\underline{\textbf{D2.7:}}
\begin{itemize}
\item $|x|_a$ ist die Anzahl der Vorkommen von a in x
\item $|A|$ die KArdinalität der Menge A
\item \textbf{P(A)} = $\{S|S\subseteq A\}$ die Potenzmenge von A
\end{itemize}


\underline{\textbf{D2.8:}} Sei $\sum = \{s_1,s_2,...,s_m\}, m\geq 1$ ein Alphabet und sei $s_1<s_2<...<s_m$ eine Ordnung auf $\sum$. Wir definieren die \textbf{kanonische Ordnung} auf $\sum^*$ für u,v $\in \sum^*$ wie folgt:

\begin{center}
$u<v \iff |u|<|v| \lor  |u|=|v| \land u = x \cdot s_i \cdot u' \land v = x \cdot s_j \cdot v'$ für irgendwelche $x,u',v' \in \sum^*$ und $i<j$ 

\end{center}


\underline{\textbf{D2.9:}} 
\begin{figure}[H]
\centering
\includegraphics[width = 120mm]{T1.png}
\end{figure}

\underline{\textbf{L2.1}} Seien $L_1,L_2,L_3$ Sprachen über einem Alphabet $\sum$. Dann gilt:
\begin{center}
$L_1L_2 \cup L_1L_3 = L_1(L_2 \cup L_3)$
\end{center}
\underline{\textbf{L 2.2}} Seien $L_1,L_2,L_3$ Sprachen über einem Alphabet $\sum$. Dann gilt:
\begin{center}
$L_1(L_2 \cap L_3) \subseteq L_1L_2 \cap L_1L_3)$
\end{center}

\underline{\textbf{L2.3}} Es existieren $U_1,U_2,U_3 \in (\sum_{bool})^*$ so dass
\begin{center}
$U_1(U_2 \cap U_3) \subset U_1U_2 \cap U_1U_3$
\end{center}

\underline{\textbf{D2.10:}} Seiene $\sum_1$ und $\sum_2$ zwei beleibige Alphabete. Ein \textbf{Homomorphismus} von $\sum_1^*$ nach $\sum_2^*$ ist jede FUnktion $h: \sum_1^* \rightarrow \sum_2^*$ mit den folgendend Eigenschaften
\begin{itemize}
\item $h(\lambda) = \lambda$
\item $h(uv) = h(u) \cdot h(v)$ für alle $u,v \in \sum_1^*$
\end{itemize}

\section{2.3 Algorithmische Probleme}

\underline{\textbf{D2.11:}} Das\textbf{Entscheidungsproblem ( $\sum$,L)} für ein gegebenes Alphabet $\sum$ und eine gegebene Sprache $L \subseteq \sum^*$ ist, für jedes $x \in \sum^*$ zu entscheiden, ob
\begin{center}
$x \in L \text{ oder } x \notin L$
\end{center}
Wenn ein Algorithmus A die Entscheidungsproblem löst sagen wir auch, dass A die sprache L \textbf{erkennt}.\\
Wenn für eine Sprache L ein Algorithmus existiert, der L erkennt sagen wir dass L \textbf{rekursiv} ist
\begin{figure}[H]
\centering
\includegraphics[width = 120mm]{T2.png}
\end{figure}

\underline{\textbf{D2.12:}} Seien $\sum$ und $\Gamma$ zwei Alphabete. Wir sagen dass ein Algorithmus A eine \textbf{ Funktion (Transformation) $f: \sum^* \rightarrow \Gamma^*$ berechnet (realisiert)} falls 
\begin{center}
$A(x) = f(x)$ für alle $x\in \sum^*$
\end{center}

\underline{\textbf{D2.13:}} Seien $\sum$ und $\Gamma$ zwei Alphabete und sei $R \subseteq \sum^* \times \Gamma^*$ eine Relation in $\sum^*$ und $\Gamma^*$. Ein Algorithmus \textbf{A berechnet R (oder löst das Relationsproblem R)} falls für jedes $x \in \sum^*$, für das ein $y \in \Gamma^*$ mit $(x,y) \in R$ existiert gilt:
\begin{center}
$(x,A(x)) \in R$
\end{center} 
\begin{figure}[H]
\centering
\includegraphics[width = 120mm]{T3.png}
\end{figure}

\underline{\textbf{D2.14:}} \textbf{Optimierungsproblem:}
\begin{figure}[H]
\centering
\includegraphics[width = 120mm]{T4.png}
\end{figure}

\underline{\textbf{Teilproblem:}} Ein Optimierungsproblem $U_1 = (\sum_I,\sum_O,L',M,cost,goal)$  ist ein Teilproblem des Optimierungsproblems $U_2 =(\sum_I,\sum_O,L,M,cost,goal)$ falls $L'\subseteq L$

\underline{\textbf{Knotenüberdeckung:}} Eine Knotenüberdeckung eines Graphen ist jede Knotenmenge $U \subseteq V$, so dass jede Kante aus E zu mindestens einem Knoten aus U inzident ist.

\underline{\textbf{D2.15:}} Sei $\sum$ ein Alphabet, und sei $x \in \sum^*$. Wir sagen, dass ein Algorithmus A das Wort x \textbf{generiert}, falls A für die Eingabe $\lambda$ die Ausgabe x liefert.

\underline{\textbf{D2.16:}} Sei $\sum$ ein Alphabetm und sei $L \subseteq \sum^*$. A ist ein \textbf{Aufzählungsalgorithmus für L}, falls A für jede Eingabe $n \in \mathbb{N}-\{0\}$ die Wortfolge $x_1,x_2,...,x_n$ ausgibt, wobei $x_1,x_2,...,x_n$ die kanonisch n ersten Wörter in L sind.

\section{Kolmogorov-Komplexität}

\underline{\textbf{Komprimierung}} Die Erzeugung einer kürzeren Darstellung eines Wortes x.

\underline{\textbf{D2.17:}} Für jedes Wort $x \in (\sum_{bool})^*$ ist die \textbf{Kolmogorov-Komplexität K(x)} des Wortes x das Minimum der binären Längen der Pascal-Programme die x generieren.

\underline{\textbf{L2.4}}Es existiert eine Konstante d, so dass für jede $x \in (\sum_{bool})^*$
\begin{center}
$K(x) \leq |x|+d$
\end{center}

\underline{\textbf{D2.18:}} Die Kolmogorov-Komplexität einer natürlichen Zahl n ist 
\begin{center}
$K(w_n) = K(Bin(n))$
\end{center} 

\underline{\textbf{L 2.5}} Für jede Zahl $n \in \mathbb{N}-\{0\}$ existiert ein Wort $w_n \in (\sum_{bool})^n$ so dass
\begin{center}
$K(w_n) \geq |w_n| = n$
\end{center}
d.h es existiert für jede Zahl n ein nichtkomprimierbares Wort der Länge n

\underline{\textbf{Satz 2.1}} Seien A und B programmiersprachen. Es existiert eine Konstante $c_{A,B}$, die nur von A und B abhängt so dass
\begin{center}
$|K_A(x) -K_B(x)| \leq c_{A,B}$
\end{center}
für alle $x \in (\sum_{bool})^*$

\underline{\textbf{D2.19:}} Ein Wort $x \in (\sum_{bool})^*$ heisst \textbf{zufällig}, falls $K(x) \geq |x|$. Eine Zahl n heisst \textbf{zufällig}, falls 
\begin{center}
$K(n) = K(Bin(n)) \geq \lceil log_2(n+1)\rceil -1$
\end{center} 

\underline{\textbf{Satz 2.2}} Sei L eine Sprache über $\sum_{bool}$. Sei für jedes $n \in \mathbb{N}-\{0\}, z_n$ das n-te Wort in L bezüglich der kanonischen Ordnung. Wenn ein Programm $A_L$ existiert, das das Entscheidungsproblem $(\sum_{bool},L)$ löst, dann gilt für alle $n\in \mathbb{N}-\{0\}$, dass
\begin{center}
$K(z_n) \leq \lceil log_2(n+1) \rceil + c$
\end{center}
wobei c eine von n unabhängige Konstante ist.

\underline{\textbf{Satz 2.3 (Primzahlsatz)}}  Die Anzahl der Primzahlen wächst so schnell wie die Funktion $\frac{n}{ln(n)}$
\begin{center}
$\lim\limits_{n \to \infty} \frac{Prim(n)}{\frac{n}{ln(n)}} = 1$
\end{center}
wobei Prim(n) ist die Anzahl der Primzahlen kleiner gleich n.

\underline{\textbf{L2.6: }} Sei $n_1,n_2,n_3...$ eine steigende unendliche Folge natürlicher Zahlen mit $K(n_i) \geq \frac{\lceil log_2n_i \rceil}{2}$. Für jedes $i \in \mathbb{N}- \{0\}$ sei $q_i$ die grösste Primzahl, die die Zahl $n_i$ teilt. Dann ist die Menge:
\begin{center}
$Q = \{q_i |i \in \mathbb{N} -\{0\}\}$
\end{center}
unendlich. L2.6 zeigt dass es unendlich viele Primzahlen gibt und auch dass die Menge der grössten Primzahlfaktoren einer beliebigen unendlichen FOlge natuürlicherZahlen mit nichtrivialer Kolmogorov Komplexität unendlich ist. 

\underline{\textbf{Satz 2.4}} Für unendlich viele $k \in \mathbb{N}$ gilt
\begin{center}
$Prim(k) \geq \frac{k}{2^{17}log_2(k) \cdot (log_2(log_2(k)))^2}$
\end{center}

\chapter{Endliche Automaten}

\section{Die Darstellungen der endlichen Automaten}

Ein Berechnungsmodell muss die folgende Fragen beantworten:
\begin{enumerate}
\item Welche elementaren Operationen, aus denen man die Programme zusammenstellen kann, stehen zur Verfügung?
\item Wie viel Speicher steht zur Verfügung und wie geht man mit dem Speicher um?
\item Wie wird die Eingabe eingegeben?
\item Wie wird die Ausgabe bestimmt (ausgegeben)?
\end{enumerate}

Bei endlichen Automaten hat man nur den folgenden Speicher:
\begin{itemize}
\item Speicher in dem das Programm gespeichert wird
\item Zeiger der auf die angewendete Zeile des Programms zeigt
\end{itemize}
Daraus folgt, das Programm darf keine Variablen benutzen.\\
$\Rightarrow$ Die Nummer der aktuellen Programmzeile, ist die einzige wechselnde Information

Wenn $\sum = \{a_1,a_2,...,a_k\}$ das Alphabet ist über dem die Eingaben dargestellt sind, dann darf der endliche Automoat nur den folgenden Operationstyp benutzen:
\begin{figure}[H]
\centering
\begin{subfigure}[b]{0.3\linewidth}
\includegraphics[width = \linewidth,scale = 1]{T5.png}
\end{subfigure}
\begin{subfigure}[b]{0.3\linewidth}
\includegraphics[width = \linewidth,scale = 1]{T6.png}
\end{subfigure}
\end{figure}
Dass Rechte bild ist der Fall wenn $\sum$ nur aus zwei Symbole besteht.Die Bedeutung dieser Operation( Befehl) ist , dass man das nächste Eingabesymbol liest und mit $a_1,a_2,...,a_k$ vergliecht. Wenn es gleich $a_j$ ist, setzt das Programm die ARbeit in der Zeile $i_j$ fort.\\
Wir nummerieren die Zeilen mit natürlichen Zahlen $0,1,2,3...$ und die Arbeit des Programms beginnt immer in der Zeile 0.\\
Solche Programme benutzt man um Entscheidungsprobleme zu lösen. Die antwort is durch die Zeilennummer bestimmt. Wenn nach dem Lesen der gesamten Eingabe des Programm in der j-ten Zeile endet, und $j \in F $ ( F eine Teilmenge von den Zeilen der Programm ist) dann akzeptiert das Programm die Eingabe sonst nicht. Bsp:
\begin{figure}[H]
\centering
\begin{subfigure}[b]{0.6\linewidth}
\includegraphics[width = \linewidth,scale = 1]{T7.png}
\end{subfigure}
\end{figure}
Die Berechnung endet in zeile 3, und weil $3 \in F$ wird das Wort 1011 akzeptiert\\

Endlichen Automaten verbindet man oft mit den Folgenden Modell:
\begin{figure}[H]
\centering
\begin{subfigure}[b]{0.4\linewidth}
\includegraphics[width = \linewidth,scale = 1]{T8.png}
\end{subfigure}
\end{figure}
Die 3 Hauptkomponente des Modells sind:
\begin{itemize}
\item \textbf{Programm:} Gespeichert
\item \textbf{Band:} Enthält das eingabe wort. Das Band betrachtet man als einen linearen Speicher für die Eingabe und besteht aus Feldern.
\item \textbf{Lesekopf:} Kann sich auf dem Band nur von links nach rechts bewegen
\end{itemize}

\underline{\textbf{Feld:}} Eine elementare Speichereinheit, die ein Symbol aus dem betrachteten Alphabet beinhalten kann

Diese Klasse von Programmen wird heute nicht mehr benutzt um endliche Automaten zu definieren, weil sie keine schöne Struktur haben. Statt dessen wird der folgender Darstellung der Programms verwendet:\\
Jeder Programm A wird einen gerichteten markierten Graphen $G(A)$ zugeordnet mit folgenden eigenschaften:

\begin{itemize}
\item G(A) hat genau so viele Knoten wie das Programm A Zeilen hat
\item Jeder Zeile von A ist genau ein Knoten zugeordnet der durch die Nummer der Zeile markiert wird
\item Falls das Programm A aus einer Zeile i in die Zeile j beim Lesen eines Symbols b übergeht, dann enthält G(A) eine gerichtete Kante (i,j) mit der Markierung b
\item Jeder Knoten von G(A) hat genau den Ausgangsgrad $|\sum|$
\end{itemize}
\begin{figure}[H]
\centering
\begin{subfigure}[b]{0.4\linewidth}
\includegraphics[width = \linewidth,scale = 1]{T9.png}
\end{subfigure}
\end{figure}
Die Graphische darstellung der obigen Programm wobei doppelkreise deuten auf Elemente von F und der Knoten, der der Zeile 0 entspricht wird durch einen zusätzlichen Pfeil markiert.

\underline{\textbf{D 3.1}} Ein deterministischer \textbf{endlicher Automat (EA)} ist ein Quintupel:
\begin{center}
$M=(Q,\sum,\delta,q_0,F)$
\end{center}
wobei:
\begin{enumerate}
\item Q eine endliche Menge von \textbf{Zuständen} ist (die Menge von Zeilen eines Programms ohne Variablen)
\item $\sum$ ein Alphabet, genannt \textbf{Eingabealphabet} ist (die zulässigen Eingaben sind all Wörter über $\sum$)
\item $q_0 \in Q$ ist der Anfangszustand (die Zeile 0 des Programms ohne Variablen)
\item $F \subseteq Q$ die \textbf{Menge der akzeptierten Zustände} ist
\item $\delta$ eine Funktion von $Q \times \sum$ nach Q ist, die $\textbf{Übergangsfunktion}$ ($\delta(q,a) = p$ bedeutet, dass M in den Zustand p übergeht, falls M im Zustand q das Symbol a gelesen hat)
\end{enumerate}

\underline{\textbf{Konfiguration:}} von M ist ein Element aus $Q \times \sum^*$  (Wenn M sich in einer Konfiguration $(q,w) \in Q \times \sum^*$ befindet, bedeutet das, dass M im Zustand q ist und noch das Suffix w eines Eingabewortes lesen soll\\
\underline{\textbf{ Startkonfiguration von M auf x:}} die Konfiguration $(q_0,x) \in \{q_0\} \times \sum^*$ (Die Arbeit (Berechnung) von M auf  mus in der startkonfiguration anfangen)

\underline{\textbf{Endkonfiguration: }} Jede Konfiguration aus $Q \times \{\lambda\}$

\underline{\textbf{ Schritt}} von M ist eine Relation (auf Konfigurationen)
\begin{center}
$\vdash_M \subseteq (Q \times \sum^*) \times (Q\times \sum^*)$
\end{center}
definiert durch:
\begin{center}
$(q,w) \vdash_M (p,x) \iff w=ax, a \in \sum$ und $\delta(q,a) = p$
\end{center}
Ein Schritt entspricht einer Anwendung der Übergangsfunktion auf die aktuelle Konfiguration in der sich M in einem Zustand q befindet und ein Eingabesymbol a liest.
\begin{figure}[H]
\centering
\begin{subfigure}[b]{0.49\linewidth}
\includegraphics[width = \linewidth,scale = 1]{T10.png}
\end{subfigure}
\begin{subfigure}[b]{0.49\linewidth}
\includegraphics[width = \linewidth,scale = 1]{T11.png}
\end{subfigure}
\end{figure}
\underline{\textbf{D 3.2}} 
\begin{figure}[H]
\centering
\begin{subfigure}[b]{0.49\linewidth}
\includegraphics[width = \linewidth,scale = 1]{T12.png}
\end{subfigure}
\end{figure}

\underline{\textbf{L 3.1}} 
\begin{center}
$L(M) = \{w \in \{0,1\}^* | |w|_0 + |w|_1 \equiv 0 mod 2 \}$
\end{center}

Jeder EA teilt die Menge $\sum^*$ in $|Q|$ Klassen auf
\begin{center}
$K1[p] = \{w \in \sum^" | \hat{\delta}(q_0,w) = p \} = \{ w \in \sum^* | (q_0,w) \vdash_M^*(p,\lambda)\}$
\end{center}
es gilt:
\begin{itemize}
\item $\bigcup_{p\in Q}K1[p] = \sum^*$ 
\item $K1[p] \cap K1[q] = \emptyset \forall p,q \in Q, p\neq q$
\item $L(M) = \bigcup_{p\in F} K1[p]$
\end{itemize}
Die Relation $R_{delta}$ die durch
\begin{center}
$x R_{\delta} y \iff \hat{\delta}(q_0,x) = \hat{\delta}(q_0,y)$
\end{center}
wird eine Äquivalenzrelation auf $\sum^*$, die die endlich vielen Klassen $K1[p]$ bestimmt

\section{Simulationen}

Jeder elementare Schritt der simulierten Berechnung wird durch einen Schritter der simulierenden Berechnung nachgemacht.

\underline{\textbf{L 3.2}} Sei $\sum$ ein Alphabet und seien $M_1 = (Q_1,\sum,\delta_1,q_{01},F_1)$ und $M2=(Q_2, \sum,\delta_2,q_{02},F_2)$ zwei EA. Für jede Mengenoperation $\odot \in \{\cup,\cap,--\}$ existiert ein EA M, so dass
\begin{center}
$L(M) = L(M_1) \odot L(M_2)$
\end{center}

\underline{Beweis Idee:} Wir konstruieren M so, dass es die Arbeit der beiden Automaten $M_1,M_2$ simulieren kann. Die Zustände von M werden Paare (q,p) zugeordnet, wobei dass erste Element von (q,p) soll q sein genau dann, wenn sich $M_1$ gerade im Zustand q befindet. Analog das zweite Element für $M_2$

\begin{figure}[H]
\centering
\begin{subfigure}[b]{0.49\linewidth}
\includegraphics[width = \linewidth,scale = 1]{T13.png}
\end{subfigure}

\end{figure}

Um die Behauptung $L(M) =L(M_1) \odot L(M_2)$ für jedes $\odot \in \{\cup,\cap,--\}$ zu beweisen, reicht es, die folgende Gleichheit zu zeigen:
\begin{center}
$\tilde{\delta}((q_{01},q_{02},x) =(\tilde{\delta_1}(q_{01},x),\tilde{\delta_2}(q_{02},x))$ für alle $x \in \sum^*$
\end{center}
Diese Gleichheit können wir mit induktion zeigen. 
\begin{figure}[H]
\centering
\begin{subfigure}[b]{0.49\linewidth}
\includegraphics[width = \linewidth,scale = 1]{T14.png}
\end{subfigure}

\end{figure}


\section{Beweise der Nichtexistenz}

Um zu zeigen, dass eine Sprache L nicht regulär ist ($L \notin \mathcal{L}_{EA}$), genügt es zu beweisen dass es keinen EA gibt, der die Sprache akzeptiert. Solcher Beweise nennt man \textbf{Beweise der Nichtexistenz}.\\
Wir wissen, dass endliche Automaten keine andere Speichermöglichkeit als den aktuellen Zustand besitzen. Das bedeutet für einen EA A, der nach dem Lesen zweier unterschiedlicher Wörter x und y im gleichen Zustand endet (also $\tilde{\delta}(q_0,x) =\tilde{\delta}(q_0,y)) $, dass A in Zukunft nicht mehr zwischen x und y unterscheiden kann. D.h für all $z \in \sum^*$ gilt, dass
\begin{center}
$\tilde{\delta}_A(q_0,xz) = \tilde{\delta}_A(q_0,yz)$
\end{center}

\underline{\textbf{L 3.3}} Sei $A=(Q,\sum,\delta_A,q_0,F)$ ein EA. Seien $x,y \in \sum^", x \neq y$ so dass 
\begin{center}
$(q_0,x) \vdash_A^* (p, \lambda)$ und $(q_0,y) \vdash_A^* (p, \lambda)$
\end{center}
für ein $p \in Q$ (also $\tilde{\delta}_A(q_0,x) = \tilde{\delta}_A(q_0,y) = p (x,y \in K1[p]))$ Dann existiert für jedes $z \in \sum^*$ ein $r \in Q$, so dass xz und yz $\in K1[r]$ also gilt insbesondere:
\begin{center}
$xz \in L(A) \iff yz \in L(A)$
\end{center}
Wenn man einmal in den Berechnungen auf zwei unterschiedlichen Eingaben, die gleiche Konfiguration erreicht, dann ist der weitere Verlauf beider Berechnungen identisch. Im Fall eines Entscheidungsproblems bedeutet dies, dass entweder beide Eingaben akzeptiert werden oder beide verworfen werden. \\

Es gibt zwei Methoden zum Bewies von nicht regularität:
\begin{itemize}
\item \textbf{Pumping:} Sei L regulär, dann existiert eine Konstante $n_0 \in \mathbb{N}$, so dass sich jedes Wort $w \in \sum^*$ mit $|w| \geq n_0$ in drei Teile y,x und z zerlegen lässt, das heisst $w = yxz$ wobei:
\begin{enumerate}
\item $|yx| \leq n_0$
\item $|x| \geq 1$
\item entweder $\{yx^kz| k \in \mathbb{N}\} \subseteq L\}$ oder $\{yx^kz | k \in \mathbb{N}\} \cap L = \emptyset$
\end{enumerate}
\item
\end{itemize}








\end{document}